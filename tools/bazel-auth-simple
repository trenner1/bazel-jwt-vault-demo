#!/usr/bin/env python3
"""
Bazel Authentication CLI Tool (Simplified Version)

This tool provides a seamless authentication experience for developers using Bazel builds
with Vault integration. It handles the complete OIDC flow with minimal dependencies.

Usage:
    ./bazel-auth-simple                    # Get authentication URL for manual flow
    ./bazel-auth-simple --session-id ID    # Exchange session ID for token
"""

import os
import sys
import json
import subprocess
import argparse
import webbrowser
from urllib.parse import quote

def run_curl(url, method="GET", data=None, headers=None):
    """Run curl command and return response"""
    cmd = ["curl", "-s"]
    
    if method == "POST":
        cmd.extend(["-X", "POST"])
    
    if headers:
        for key, value in headers.items():
            cmd.extend(["-H", f"{key}: {value}"])
    
    if data:
        if isinstance(data, dict):
            data = json.dumps(data)
        cmd.extend(["-d", data])
        if "-H" not in cmd or "Content-Type" not in " ".join(cmd):
            cmd.extend(["-H", "Content-Type: application/json"])
    
    cmd.append(url)
    
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        return result.stdout
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"curl failed: {e.stderr}")

def start_auth_flow(broker_url):
    """Start the PKCE authentication flow"""
    try:
        response = run_curl(f"{broker_url}/cli/start", method="POST")
        return json.loads(response)
    except Exception as e:
        raise RuntimeError(f"Failed to start auth flow: {e}")

def exchange_session(broker_url, session_id, metadata=None):
    """Exchange session_id for a Vault token"""
    if metadata is None:
        metadata = {}
    
    payload = {
        "session_id": session_id,
        "pipeline": metadata.get("pipeline", "bazel-cli"),
        "repo": metadata.get("repo", "unknown"),
        "target": metadata.get("target", "unknown")
    }
    
    try:
        response = run_curl(f"{broker_url}/exchange", method="POST", data=payload)
        return json.loads(response)
    except Exception as e:
        raise RuntimeError(f"Failed to exchange for Vault token: {e}")

def main():
    parser = argparse.ArgumentParser(description="Bazel Authentication CLI Tool (Simplified)")
    parser.add_argument("--broker-url", default="http://localhost:8081", 
                       help="Broker service URL")
    parser.add_argument("--session-id", help="Session ID to exchange for token")
    parser.add_argument("--pipeline", help="Pipeline name for metadata")
    parser.add_argument("--repo", help="Repository name for metadata") 
    parser.add_argument("--target", help="Build target for metadata")
    parser.add_argument("--token-only", action="store_true",
                       help="Only output the token")
    parser.add_argument("--export", action="store_true",
                       help="Output export command for shell evaluation")
    parser.add_argument("--no-browser", action="store_true",
                       help="Don't auto-open browser")
    
    args = parser.parse_args()
    
    # Prepare metadata
    metadata = {}
    if args.pipeline:
        metadata["pipeline"] = args.pipeline
    if args.repo:
        metadata["repo"] = args.repo  
    if args.target:
        metadata["target"] = args.target
    
    try:
        if args.session_id:
            # Exchange mode - user provides session ID
            print("Exchanging session ID for Vault token...", file=sys.stderr)
            token_data = exchange_session(args.broker_url, args.session_id, metadata)
            vault_token = token_data["token"]
            
            if args.token_only:
                print(vault_token)
            elif args.export:
                print(f"export VAULT_TOKEN={vault_token}")
            else:
                print(f"Authentication successful!", file=sys.stderr)
                print(f"   Token: {vault_token[:20]}...", file=sys.stderr)
                print(f"   TTL: {token_data.get('ttl', 'unknown')} seconds", file=sys.stderr)
                print(f"   Team: {token_data.get('metadata', {}).get('team', 'unknown')}", file=sys.stderr)
                print(f"", file=sys.stderr)
                print(f"To use this token:", file=sys.stderr)
                print(f"   export VAULT_TOKEN={vault_token}", file=sys.stderr)
        else:
            # Start auth flow mode
            print("Starting Bazel authentication flow...", file=sys.stderr)
            
            auth_data = start_auth_flow(args.broker_url)
            auth_url = auth_data["auth_url"]
            state = auth_data["state"]
            
            print(f"", file=sys.stderr)
            print(f"Authentication URL:", file=sys.stderr)
            print(f"   {auth_url}", file=sys.stderr)
            print(f"", file=sys.stderr)
            print(f"Next steps:", file=sys.stderr)
            print(f"   1. Open the URL above in your browser", file=sys.stderr)
            print(f"   2. Complete Okta authentication", file=sys.stderr)
            print(f"   3. Copy the session_id from the callback page", file=sys.stderr)
            print(f"   4. Run: ./bazel-auth-simple --session-id <SESSION_ID>", file=sys.stderr)
            print(f"", file=sys.stderr)
            
            if not args.no_browser:
                print("Opening browser...", file=sys.stderr)
                webbrowser.open(auth_url)
            
            # For easy copying, output just the URL to stdout
            if args.export:
                print(f"# Open this URL and then use --session-id with the result")
                print(f"# {auth_url}")
            elif args.token_only:
                print("# Use --session-id after completing browser authentication")
            else:
                print(auth_url)
                
    except KeyboardInterrupt:
        print("\nAuthentication cancelled by user", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"Authentication failed: {e}", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()